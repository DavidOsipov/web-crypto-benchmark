# The Official Security & Engineering Constitution (v6.1.1 - Living Document)

**Document Status:** Final, Mandatory
**SPDX-License-Identifier:** MIT
**SPDX-FileCopyrightText:** © 2025 David Osipov <personal@david-osipov.vision>

## 0. Introduction

### 0.1. Goals & Vision

This document codifies the security and engineering architecture for this project. Our guiding philosophy is **Zero Trust**. We do not trust the network, we do not trust third-party code, and we do not even trust our own code to be infallible. Every component is built with the assumption that other parts of the system could be compromised. Security is not a feature; it is the foundation upon which all features are built.

This constitution is a living document, designed to be prescriptive, actionable, and verifiable. It serves as a single source of truth for developers, security engineers, and automated tooling.

### 0.2. Audience & Scope

This constitution is mandatory for all personnel contributing code to the project. It applies to all frontend JavaScript, backend services, CI/CD pipelines, and infrastructure configurations. Its rules are intended to be parsed and enforced by automated systems (linters, scanners, CI gates) as well as human reviewers.

### 0.3. Change Process & Versioning

This constitution is versioned semantically (e.g., v6.0.1). Any change requires a formal security review and sign-off by at least one designated security owner. Emergency bypass procedures must be documented, logged, and followed by a retrospective analysis.

*   **Owner:** Security Team Lead
*   **Approvers:** Lead Engineers, Security Team
*   **Changelog:** All changes are tracked in a `CHANGELOG.md` accompanying this document.

---

## Part I: Core Philosophy & Principles

These are the fundamental mindsets that guide all engineering decisions.

### 1.1. Secure by Default
The default state of the application is the most secure state. Insecure actions must be explicit, deliberate, and are therefore forbidden.

### 1.2. Defense in Depth
We layer multiple, independent security controls. A failure in one layer is caught by the next. We will never rely on a single control for a critical defense. Every security-sensitive operation **must** implement multiple, independent layers of protection to account for browser implementation differences and feature support gaps (e.g., Trusted Types in Chrome vs. Firefox).

### 1.3. Principle of Least Privilege (PoLP)
Every component, module, and function must operate with the minimum level of privilege and access to data necessary to perform its function. State is encapsulated (`#private`), configuration is immutable (`Object.freeze`), and DOM access is restricted.

### 1.4. Fail Loudly, Fail Safely
In the face of an error or an unavailable security primitive (e.g., `window.crypto`), the system will throw a specific, catchable error and disable the feature. It will **never** fall back to an insecure alternative (e.g., `Math.random()`). Components must implement circuit breakers to automatically disable themselves if error thresholds are exceeded.

### 1.5. Verifiable Security
A security control is considered non-existent until it is validated by an automated, adversarial test in our CI/CD pipeline. All security claims must be provable with code.

### 1.6. Performance is a Security Feature
A performant, non-blocking UI prevents timing attacks, provides a better user experience, and reduces the likelihood of user error. We mandate the use of modern, performant APIs (`IntersectionObserver` over `onscroll`, Web Animations API over class toggling).

---

## Part II: Architectural Mandates

These are non-negotiable, environment-level security controls enforced at the browser and server level.

### 2.1. Content Security Policy (CSP)
*   **Statement:** The application **MUST** be served with a strict, hash-based CSP to mitigate XSS and data injection attacks.
*   **Rationale:** This is our first and most powerful line of defense. It instructs the browser to only trust and execute scripts and styles that we have explicitly authorized via hashes calculated at build time.
*   **Implementation:** The following HTTP header **MUST** be sent with every page response:
    ```http
    Content-Security-Policy:
      default-src 'self';
      script-src 'self' 'sha256-...' 'sha256-...'; /* Add hashes of inline scripts generated by Astro build */
      style-src 'self' 'sha256-...' 'sha256-...'; /* Add hashes of inline styles generated by Astro build */
      img-src 'self' data:;
      font-src 'self';
      object-src 'none';
      base-uri 'self';
      form-action 'self';
      frame-ancestors 'none';
      require-trusted-types-for 'script';
      trusted-types app-policy default;
    ```
*   **Forbidden:** Using `'unsafe-inline'` (without hashes), `'unsafe-eval'`, or wildcard sources like `*`.

### 2.2. Trusted Types
*   **Statement:** All assignments to dangerous DOM sinks (`innerHTML`, `outerHTML`, `script.src`, etc.) **MUST** use a `TrustedType` object. Direct string assignment is forbidden by the CSP.
*   **Rationale:** CSP does not protect against DOM-based XSS. Trusted Types moves sink protection from the server to the client, making such attacks impossible by default in supporting browsers. The reference implementation for creating `TrustedType` objects is `DOMPurify` (see Appendix C).
*   **Implementation:** Use a centralized `app-policy` that sanitizes input (e.g., with DOMPurify) before creating a `TrustedHTML` object. A `default` policy must be in place to block and log any direct string assignments.

### 2.3. Subresource Integrity (SRI)
*   **Statement:** All third-party assets (JS, CSS) loaded from external domains (CDNs) **MUST** include the `integrity` attribute.
*   **Rationale:** Mitigates supply chain attacks where a CDN could be compromised. SRI guarantees that the browser will only execute the exact file we intended.
*   **Example:**
    ```html
    <script src="https://cdn.example.com/library.js"
            integrity="sha384-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxy9rx7HNQlGYl1kPzQho1wx4JwY8wJ"
            crossorigin="anonymous"></script>
    ```

### 2.4. Hardened HTTP Headers
*   **Statement:** The server **MUST** send additional security headers to disable insecure browser features.
*   **Rationale:** These headers close various attack vectors, from clickjacking to MIME-type sniffing.
*   **Implementation:**
    ```http
    Strict-Transport-Security: max-age=63072000; includeSubDomains; preload
    X-Content-Type-Options: nosniff
    X-Frame-Options: DENY
    Referrer-Policy: strict-origin-when-cross-origin
    Permissions-Policy: geolocation=(), microphone=(), camera=()
    ```

### 2.5. Runtime Environment Assertions
*   **Statement:** At startup, the application **MUST** assert the presence of required browser security primitives (e.g., `window.trustedTypes`, `window.crypto.subtle`).
*   **Rationale:** A misconfigured environment or unsupported browser could lead to silent security failures. We must fail loudly and safely.
*   **Implementation:**
    ```javascript
    if (typeof window.trustedTypes === 'undefined') {
      console.error('[Security]: Trusted Types API not available. Critical DOM features will be disabled.');
      // Activate a circuit-breaker to disable features relying on Trusted Types.
    }
    ```
### 2.6. Source Map Security (MUST NOT)
*   **Statement:** Source maps (`.map` files) **MUST NOT** be deployed to public production environments.
*   **Rationale:** While invaluable for debugging, source maps expose the original, unminified source code. This includes comments, variable names, and the original file structure, which provides a detailed roadmap for attackers looking to find vulnerabilities in the application logic. (Из Главы 3.6).
*   **Implementation:**
    *   The production build process **MUST** be configured to disable source map generation or prevent the `.map` files from being uploaded to the public web server.
    *   If source maps are required for production error monitoring (e.g., for a service like Sentry), they **MUST** be uploaded directly to that secure, private service and not be publicly accessible via a URL.

#### **2.7. Client-Side Secret Prohibition (MUST NOT)**
*   **Statement:** API keys, tokens, or any other secrets **MUST NOT** be embedded in the client-side JavaScript bundle.
*   **Rationale:** All code and assets on a static site are publicly downloadable and inspectable. Embedding secrets in the JavaScript source is equivalent to publishing them publicly. This can lead to immediate abuse of third-party service quotas and unauthorized access to protected APIs.
*   **Implementation:**
    *   For interactions with protected APIs, a "Backend for Frontend" (BFF) pattern **MUST** be used. This typically involves a lightweight serverless function (e.g., AWS Lambda, Cloudflare Worker) that acts as a proxy.
    *   The serverless function holds the secret and makes the request to the third-party API on behalf of the client. The static site communicates only with this trusted serverless function.
    *   This pattern ensures that secrets never leave the secure server-side environment.

This architectural rule is non-negotiable for any static site that needs to interact with a protected API.

### 2.8. Cross-Origin Resource Sharing (CORS) Policy (MUST)
*   **Statement:** The frontend application **MUST** be built with the expectation that all cross-origin APIs adhere to a strict, non-wildcard CORS policy.
*   **Rationale:** While CORS is a server-enforced mechanism, a secure frontend architecture relies on it being configured correctly. Assuming a strict policy prevents the development of features that would fail in a secure environment and reinforces our Zero Trust model for network interactions. (Из Главы 6.3).
*   **Implementation:**
    1.  All cross-origin `fetch()` requests that require authentication (e.g., to a BFF) **MUST** include the `credentials: 'include'` option.
    2.  The application **MUST** expect the server to respond with a specific `Access-Control-Allow-Origin` header (e.g., `https://your-site.com`), not a wildcard (`*`), when credentials are included.
    3.  Automated integration tests **SHOULD** verify that API calls fail as expected if the server were to return an invalid CORS header.

### 2.9. Secure Cross-Context Communication (postMessage) (MUST)
*   **Statement:** All communication between different window contexts (e.g., `window` and an `<iframe>`) **MUST** use the `postMessage` API with strict origin validation.
*   **Rationale:** Directly accessing content between frames from different origins is blocked by the Same-Origin Policy. The `postMessage` API provides a secure channel for this communication, but it can be abused if not implemented correctly. Failing to validate the origin of an incoming message can allow a malicious page to impersonate a trusted source and exfiltrate data or trigger unwanted actions. (Из Главы 8, "Patterns for secure frame/native WebView bridge messaging").
*   **Implementation (Receiving Messages):**
    1.  An allowlist of trusted origins **MUST** be maintained.
    2.  The `event.origin` property of every incoming message **MUST** be checked against this allowlist before any data is processed.
    ```javascript
    const ALLOWED_MESSAGE_ORIGINS = ['https://trusted-partner.com'];

    window.addEventListener('message', (event) => {
      // CRITICAL: Always verify the sender's origin.
      if (!ALLOWED_MESSAGE_ORIGINS.includes(event.origin)) {
        console.warn(`[Security]: Dropping message from non-allowlisted origin: ${event.origin}`);
        return;
      }

      // Now it's safe to process event.data
      const { type, payload } = JSON.parse(event.data);
      // ...
    });
    ```
*   **Implementation (Sending Messages):**
    1.  When sending a message via `targetWindow.postMessage()`, the `targetOrigin` parameter **MUST** be set to a specific origin (e.g., `https://trusted-partner.com`), not a wildcard (`*`).
    ```javascript
    // GOOD: Ensures the message is only sent if the recipient is at the expected origin.
    const targetOrigin = 'https://trusted-partner.com';
    iframe.contentWindow.postMessage('sensitive-data', targetOrigin);

    // BAD: Leaks data to any origin the iframe may have navigated to.
    iframe.contentWindow.postMessage('sensitive-data', '*');
    ```

#### **2.10. Progressive Web App (PWA) Mandates. Service Worker Security (MUST)**
*   **Statement:** Any Service Worker script (`sw.js`) **MUST** be implemented with strict security controls to prevent scope hijacking and cache poisoning.
*   **Rationale:** A Service Worker acts as a powerful, programmable network proxy for your application. A compromised Service Worker can intercept requests, serve malicious content, and remain active even after the user has left the site. Its security is therefore paramount. (Из Главы 8.7).
*   **Implementation:**
    1.  **Scope Limitation:** The Service Worker **MUST** be registered with the narrowest possible scope required for its functionality (e.g., `/app/` instead of `/`). This prevents it from controlling pages it shouldn't, like an admin login page served from the same domain.
    2.  **Secure Caching:** Sensitive or user-specific API responses **MUST NOT** be stored in the Service Worker cache unless encrypted. All cached assets must be served over HTTPS.
    3.  **Secure Updates:** The update process for a Service Worker **MUST** be secure. Any script that triggers an update (`registration.update()`) must ensure the new `sw.js` file is loaded from a trusted, secure origin.
    4.  **Input Sanitization:** All data received from `postMessage` or Push API events **MUST** be sanitized and validated before being acted upon, to prevent injection attacks targeting the Service Worker itself.
    5.  **Cache Poisoning Prevention:** The Service Worker **MUST** validate the integrity of responses before caching them, especially for resources from third-party origins. Responses that are opaque or have error status codes (e.g., not in the 2xx range) **MUST NOT** be cached to prevent serving broken or malicious content while offline.
    6.  **Secure Script Location:** The Service Worker script (`sw.js`) **MUST** be served from the root of its scope and its location **MUST NOT** be controllable by user input (e.g., via a URL parameter) to prevent loading a malicious script.

---

## Part III: Secure Implementation Rules

This section provides prescriptive, code-level rules for all developers. Each rule follows a standard format for clarity and automated enforcement.

### A. DOM Interaction & Rendering

#### RULE: Selector Safety (MUST)
*   **Statement:** Never interpolate unescaped user or server data into `querySelector` strings.
*   **Rationale:** Prevents selector injection vulnerabilities and `DOMException` errors from malformed selectors.
*   **Good (Attribute Matching):**
    ```javascript
    // Safe: Avoid composing selector strings from untrusted input.
    const headingId = sanitizeId(id); // Use a deterministic sanitizer.
    const activeLink = Array.from(container.querySelectorAll('.toc-link'))
      .find(l => l.getAttribute('data-heading-id') === headingId);
    ```
*   **Good (CSS.escape):**
    ```javascript
    const escapedId = CSS.escape(id);
    const activeElement = container.querySelector(`[data-heading-id="${escapedId}"]`);
    ```
*   **Bad:**
    ```javascript
    // VULNERABLE: `id` could contain "]", breaking the selector.
    const activeElement = container.querySelector(`[data-heading-id="${id}"]`);
    ```
*   **Tests:** Unit tests must feed malicious IDs containing `"` and `]` and verify lookup works correctly without throwing exceptions.
*   **CI Check:** ESLint rule (`no-queryselector-interpolation`) that warns on string interpolation inside `querySelector` calls.

#### RULE: Secure & Performant Script Loading (MUST)
*   **Statement:** All external third-party scripts **MUST** be loaded using either the `defer` or `async` attribute to prevent render-blocking. `defer` is preferred for scripts that need the DOM to be ready, while `async` is for independent, self-contained scripts. If it is possible, offload non-essential scripts to a worker thread.
*   **Rationale:** A standard `<script>` tag blocks HTML parsing while it is being fetched and executed. This creates a poor user experience and can be a vector for performance degradation. Using `defer` ensures scripts execute in order after the document is parsed but before `DOMContentLoaded`, making it the safest default. `async` executes as soon as the script is downloaded, which can be useful but risks unpredictable execution order. This aligns with the asset loading optimizations discussed in Chapter 10.
*   **Good (Preferred):**
    ```html
    <!-- Non-critical analytics or UI script that should not block rendering. -->
    <script src="https://analytics.example.com/tracker.js" defer></script>
    ```
*   **Good (For independent scripts):**
    ```html
    <!-- A third-party script that has no dependencies on the DOM or other scripts. -->
    <script src="https://ads.example.com/ad-loader.js" async></script>
    ```
*   **Bad:**
    ```html
    <!-- VULNERABLE: Blocks page rendering, degrading performance and user experience. -->
    <script src="https://widget.example.com/main.js"></script>
    ```
*   **CI Check:** A CI job or linter **SHOULD** scan the final HTML output for `<script>` tags lacking either an `async` or `defer` attribute and flag them for review.

#### RULE: Third-Party Script Isolation (SHOULD)
*   **Statement:** Non-essential third-party scripts, especially those for analytics, marketing, or advertising, **SHOULD** be executed in a Web Worker to isolate them from the main thread and the primary DOM.
*   **Rationale:** Third-party scripts are a significant supply chain risk. Executing them on the main thread gives them access to the `window` object, sensitive DOM content, and the ability to degrade application performance. Moving them to a worker thread via a library like Partytown severely restricts their access (e.g., no direct DOM access, proxied `localStorage`), creating a sandbox that mitigates the risk of data exfiltration and main-thread blocking. This is a practical application of executing code off the main thread as detailed in Chapter 10.
*   **Implementation:**
    *   Utilize a framework feature (like Next.js's experimental `strategy="worker"`) or a library like Partytown to manage the proxying of third-party scripts to a worker.
    *   The CSP **MUST** be configured to allow the worker scripts and any necessary `blob:` or `data:` URLs that the proxy library requires.
*   **Good:**
    ```html
    <!-- Using a library like Partytown to proxy the script -->
    <script type="text/partytown" src="https://analytics.google.com/gtm.js"></script>
    ```
*   **Bad:**
    ```html
    <!-- High Risk: Script runs on the main thread with full DOM access. -->
    <script src="https://analytics.google.com/gtm.js" async></script>
    ```
*   **Tests:** Verify that third-party scripts are correctly loaded and that their network requests originate from the worker context, not the main window context.

#### RULE: Delegated Click Handling (MUST)
*   **Statement:** Always use `event.target.closest(selector)` for delegated event handlers; `event.target.matches(selector)` is forbidden for this purpose.
*   **Rationale:** `matches()` fails if the user clicks on a nested element (e.g., a `<span>` inside an `<a>`), breaking functionality and security assumptions. `closest()` correctly traverses up the DOM tree to find the intended target.
*   **Good:**
    ```javascript
    container.addEventListener('click', (event) => {
      if (!(event.target instanceof Element)) return;
      const link = event.target.closest('a.some-delegated-link');
      if (link) {
        event.preventDefault();
        // Handle click...
      }
    });
    ```
*   **Bad:**
    ```javascript
    // FRAGILE: Fails if the click target is a child of the anchor.
    container.addEventListener('click', (event) => {
      if (event.target.matches('a.some-delegated-link')) {
        // This block may never be reached.
      }
    });
    ```
*   **Tests:** Integration test that simulates a click on a child element within the delegated parent and asserts the handler fires correctly.
*   **CI Check:** Custom ESLint rule to flag usage of `event.target.matches()` inside event listeners.

#### RULE: Separation of Pure Logic from Impure Actions (MUST)
*   **Statement:** Business logic and data transformation functions **MUST** be pure. All side effects (DOM manipulation, network requests, `localStorage` access, `console.log`) **MUST** be isolated at the boundaries of the application (e.g., in event handlers or dedicated "effect" modules).
*   **Rationale:** This principle, drawn from the core of functional programming (Chapter 4), drastically reduces the attack surface. Pure functions are deterministic, easily testable, and cannot be sources of side-effect-based vulnerabilities. By isolating impurity, we can focus our most stringent security reviews on a much smaller, well-defined part of the codebase.
*   **Implementation:**
    *   A "core" module should export pure functions that take data and return new data.
    *   An "event handler" or "controller" module imports these pure functions, calls them with the necessary state, and then uses the return value to perform the impure action (e.g., updating the DOM).
*   **Good:**
    ```javascript
    // --- pure-logic.js ---
    // Pure, testable, no side effects.
    export function createGreeting(name) {
      return `Hello, ${name}!`;
    }

    // --- event-handler.js ---
    import { createGreeting } from './pure-logic.js';
    // Impure action is isolated here.
    document.getElementById('btn').addEventListener('click', () => {
      const greeting = createGreeting('World');
      document.getElementById('output').textContent = greeting; // Side effect
    });
    ```
*   **Bad:**
    ```javascript
    // VULNERABLE & HARD TO TEST: Logic and side effects are mixed.
    function createAndDisplayGreeting(name) {
      const greeting = `Hello, ${name}!`;
      // Side effect is mixed with logic.
      document.getElementById('output').textContent = greeting;
    }
    ```
*   **CI Check:** A linter rule **SHOULD** be configured to flag the use of global objects like `document` or `window` in files located in a designated `pure-logic/` directory.

##### **RULE: Batched DOM Updates (SHOULD)**
*   **Statement:** DOM manipulations, especially those occurring in loops or in response to frequent events (e.g., `scroll`, `resize`), **SHOULD** be batched to avoid layout thrashing.
*   **Rationale:** Interleaving DOM reads (e.g., `element.offsetWidth`) and writes (e.g., `element.style.width = '...'`) forces the browser to perform repeated, synchronous layout calculations, which can block the main thread. A blocked UI is not only a poor user experience but can also make the application more susceptible to timing attacks. (Из Главы 7.1).
*   **Good (Batching with `documentFragment`):**
    ```javascript
    const fragment = document.createDocumentFragment();
    for (let i = 0; i < 100; i++) {
      const el = document.createElement('div');
      fragment.appendChild(el);
    }
    // Single write operation
    document.body.appendChild(fragment);
    ```
*   **Good (Separating Reads/Writes with `requestAnimationFrame`):**
    ```javascript
    // Read
    const currentWidth = element.offsetWidth;

    // Schedule Write
    requestAnimationFrame(() => {
      element.style.width = (currentWidth / 2) + 'px';
    });
    ```
*   **CI Check:** While difficult to enforce automatically, a linter rule could flag DOM manipulations inside loops and recommend batching patterns. This is primarily enforced during code review.

#### RULE: Predictable Error Handling via Result Types (SHOULD)
*   **Statement:** Functions that can fail for predictable reasons (e.g., parsers, validators, data extractors) **SHOULD** return a result type (e.g., an object like `{ ok: true, value: ... }` or `{ ok: false, error: ... }`) instead of throwing exceptions.
*   **Rationale:** Inspired by functional data types like `Maybe` and `Either` (Chapter 12), this pattern makes error handling explicit and declarative. It forces the calling code to handle the failure case, preventing unhandled exceptions that can lead to inconsistent application states or leak sensitive information through stack traces. It transforms error handling from an imperative `try/catch` side effect into a predictable data flow.
*   **Implementation:**
    ```typescript
    type Result<T, E> = { ok: true; value: T } | { ok: false; error: E };

    function parseJSON(raw: string): Result<object, Error> {
      try {
        return { ok: true, value: JSON.parse(raw) };
      } catch (e) {
        return { ok: false, error: e };
      }
    }
    ```
*   **Good:**
    ```javascript
    const result = parseJSON('{ "invalid" }');
    if (result.ok) {
      // Use result.value
    } else {
      // Handle result.error
      console.error('Parsing failed:', result.error.message);
    }
    ```
*   **Bad:**
    ```javascript
    // Can lead to unhandled exceptions if not wrapped in try/catch everywhere.
    try {
      const data = JSON.parse('{ "invalid" }');
    } catch (e) {
      // ...
    }
    ```
*   **CI Check:** This is a pattern to be enforced during code review, especially for utility and data processing functions.

#### RULE: Selector Normalization (MUST)
*   **Statement:** Any DOM selector derived from a URL (`href`, `src`) **MUST** be normalized to its fragment/hash before validation and use.
*   **Rationale:** Raw `href` attributes can be relative or absolute URLs. Passing a full URL to a selector validator that expects a hash (e.g., `#id`) will cause incorrect validation failures and block legitimate functionality.
*   **Good:**
    ```javascript
    const href = linkElement.getAttribute('href'); // e.g., "/page.html#ref-123"
    if (!href) return;

    let fragment;
    try {
      // Normalizes to "#ref-123" regardless of base URL.
      fragment = new URL(href, document.baseURI).hash;
    } catch (e) {
      console.error('Invalid URL for selector normalization', e);
      return;
    }

    if (fragment && SecureDOMValidator.validateSelector(fragment)) {
      const target = document.querySelector(fragment);
      // ...
    }
    ```
*   **Bad:**
    ```javascript
    // WRONG: Passes a full URL to a validator expecting a hash.
    const href = linkElement.getAttribute('href');
    if (SecureDOMValidator.validateSelector(href)) {
      // This will likely fail.
    }
    ```
*   **Tests:** Unit tests that pass relative, absolute, and malformed URLs to the normalization logic and assert correct fragment extraction or graceful error handling.
*   **CI Check:** A linter rule could heuristically check for `getAttribute('href')` being passed directly to a function named `validateSelector` or `querySelector`.

#### RULE: Prefer Direct Attribute Checking (SHOULD)
*   **Statement:** You **SHOULD** prefer safe DOM traversal and direct attribute equality checks over building dynamic attribute selectors from variables.
*   **Rationale:** Dynamically constructing attribute selectors (e.g., `[href="#${id}"]`) is brittle and can re-introduce risks of injection or escaping errors, even with sanitization. Direct attribute checking is simpler and more robust. If you **MUST** build a dynamic selector, you **MUST** adhere to the 'Selector Safety' rule using `CSS.escape()`.
*   **Good:**
    ```javascript
    const targetId = `#${sanitizedCitationId}`;
    const candidates = Array.from(targetElement.getElementsByTagName('a'));
    const returnLink = candidates.find(link => link.getAttribute('href') === targetId);
    if (returnLink) {
      // Activate link...
    }
    ```
*   **Acceptable (but not preferred):**
    ```javascript
    // This is only acceptable if the 'Good' pattern is not feasible.
    // It MUST use CSS.escape() as per the 'Selector Safety' rule.
    const escapedId = CSS.escape(sanitizedCitationId);
    const returnSelector = `a[href="#${escapedId}"]`;
    const returnLink = targetElement.querySelector(returnSelector); // Less robust than direct checking
    ```
*   **Tests:** Adversarial tests where `sanitizedCitationId` contains characters that could break an attribute selector.
*   **CI Check:** Flag `querySelectorAll` or `querySelector` calls that use template literals in the attribute selector part, and recommend the direct checking pattern.

##### **RULE: Client-Side API Response Validation (MUST)**
*   **Statement:** All data received from external APIs, even trusted first-party APIs, **MUST** be validated against an expected schema before being used by the application.
*   **Rationale:** An API could be compromised, return malformed data, or change its contract unexpectedly. Blindly trusting API responses can lead to unhandled exceptions, state corruption, and security vulnerabilities if the data is later passed to a DOM sink or other sensitive function. This extends our Zero Trust philosophy to our own infrastructure. (Inspired by Chapter 5.4).
*   **Good (Using a schema validator like Zod or Yup):**
    ```javascript
    import { z } from 'zod';

    const userSchema = z.object({
      id: z.string().uuid(),
      name: z.string(),
      isAdmin: z.boolean().default(false),
    });

    async function fetchUser(userId) {
      const response = await fetch(`/api/users/${userId}`);
      const rawData = await response.json();
      // Throws an error if data doesn't match the schema
      const validatedUser = userSchema.parse(rawData);
      return validatedUser;
    }
    ```
*   **Bad:**
    ```javascript
    // VULNERABLE: Blindly trusts the API response structure.
    async function fetchUser(userId) {
      const response = await fetch(`/api/users/${userId}`);
      const user = await response.json(); // No validation
      // user.name could be undefined, user.isAdmin could be a malicious string.
      return user;
    }
    ```
*   **CI Check:** A linter rule can encourage wrapping `fetch` responses in validation functions.

#### RULE: DOM-Attached Data (SHOULD NOT)
*   **Statement:** Do not add application state directly to DOM nodes (e.g., `element._myAppState`). Use `WeakMap<Element, State>` instead.
*   **Rationale:** Direct property assignment pollutes the DOM, can cause memory leaks if not cleaned up, and risks collisions with other scripts or future browser APIs. `WeakMap` handles garbage collection automatically.
*   **Good:**
    ```javascript
    const elementStateMap = new WeakMap();

    function attachState(element, state) {
      elementStateMap.set(element, state);
    }

    function getState(element) {
      return elementStateMap.get(element);
    }
    ```
*   **Bad:**
    ```javascript
    // LEAKY & COLLISION-PRONE
    element._myComponentState = { active: true };
    ```
*   **Tests:** Ensure components that are removed from the DOM do not retain references in memory.
*   **CI Check:** ESLint rule to ban assignment to new properties on `Element` instances.

#### RULE: Prototype Pollution Prevention (MUST NOT)
*   **Statement:** Any function that recursively merges or clones objects **MUST** explicitly check for and block keys named `__proto__`, `constructor`, or `prototype`.
*   **Rationale:** Prototype Pollution is a critical vulnerability where an attacker can inject properties into `Object.prototype`, affecting all objects throughout the application. This can lead to privilege escalation, logic bypasses, and XSS. This rule is a direct defense against this underestimated threat. (Inspired by the "Prototype Pollution: The Hidden Menace" section of the security article).
*   **Good (Explicit Check):**
    ```javascript
    function secureMerge(target, source) {
      for (const key in source) {
        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
          console.error(`[Security]: Prototype pollution attempt detected for key: ${key}`);
          continue; // Skip the dangerous key
        }
        if (typeof source[key] === 'object' && source[key] !== null) {
          if (!target[key]) target[key] = {};
          secureMerge(target[key], source[key]);
        } else {
          target[key] = source[key];
        }
      }
      return target;
    }
    ```
*   **Bad:**
    ```javascript
    // VULNERABLE: No checks for malicious keys.
    function vulnerableMerge(target, source) {
      for (const key in source) {
        if (typeof source[key] === 'object') {
          if (!target[key]) target[key] = {};
          vulnerableMerge(target[key], source[key]); // Recursive call without validation
        } else {
          target[key] = source[key];
        }
      }
    }
    ```
*   **CI Check:** SAST tools should be configured to flag recursive object-merging functions that lack checks for forbidden keys. Unit tests for these functions **MUST** include payloads designed to cause prototype pollution and assert that they are correctly handled.

#### RULE: Animation Validation & Safety (SHOULD)
*   **Statement:** Validate keyframes and options before using the Web Animations API. Use a type-checked allowlist for properties and values.
*   **Rationale:** Unvalidated input passed to the WAAPI can lead to unexpected behavior or be a vector for injecting malicious CSS values (e.g., `url(...)`).
*   **Good:**
    ```javascript
    const ALLOWED_PROPS = new Set(['transform', 'opacity', 'backgroundColor']);

    function isValidKeyframe(frame) {
      for (const prop in frame) {
        if (!ALLOWED_PROPS.has(prop)) return false;
      }
      if ('opacity' in frame) {
        const v = Number(frame.opacity);
        if (Number.isNaN(v) || v < 0 || v > 1) return false;
      }
      return true;
    }

    if (isValidKeyframe(userKeyframe)) {
      element.animate([userKeyframe], { duration: 500 });
    }
    ```
*   **Tests:** Fuzz testing that feeds malicious CSS values like `url(javascript:...)` into the validator and asserts they are rejected.
*   **CI Check:** Heuristic check for `element.animate` calls where keyframes are not statically defined or passed through a known validator function.

### B. State & Lifecycle Management

#### RULE: Event Listener Cleanup (MUST)
*   **Statement:** Prefer `AbortController` and its `signal` option for managing event listener lifecycles. Fall back to explicit `removeEventListener` only when `signal` is not supported.
*   **Rationale:** `AbortController` provides a robust, centralized, and leak-proof mechanism to clean up multiple event listeners at once, which is critical in single-page applications.
*   **Good:**
    ```javascript
    class MyComponent {
      #abortController = new AbortController();

      constructor(element) {
        const signal = this.#abortController.signal;
        element.addEventListener('click', this.onClick, { signal });
        element.addEventListener('mouseover', this.onMouseOver, { signal });
      }

      destroy() {
        this.#abortController.abort(); // Removes all listeners instantly.
      }
    }
    ```
*   **Tests:** Unit test that creates a component, calls `destroy()`, and asserts that no event handlers run afterward.
*   **CI Check:** Lint rule that encourages using `{ signal }` when available.

#### RULE: Passive Listener Safety (MUST)
*   **Statement:** If a delegated handler may call `event.preventDefault()`, its listener **MUST** be non-passive (`{ passive: false }`). Alternatively, check `event.cancelable` before calling `preventDefault()`.
*   **Rationale:** Calling `preventDefault()` inside a passive listener is a runtime error that will be thrown by the browser. This can lead to unpredictable behavior.
*   **Good (Separate Handlers):**
    ```javascript
    // Active listener for actions that need preventDefault
    container.addEventListener('click', activeHandler, { passive: false });
    // Passive listener for scrolling/observation
    container.addEventListener('scroll', passiveHandler, { passive: true });
    ```
*   **Good (Cancelable Check):**
    ```javascript
    function mixedHandler(event) {
      if (someCondition && event.cancelable) {
        event.preventDefault();
      }
    }
    container.addEventListener('click', mixedHandler, { passive: false });
    ```
*   **Bad:**
    ```javascript
    // THROWS ERROR: Calling preventDefault in a passive listener.
    container.addEventListener('click', (e) => e.preventDefault(), { passive: true });
    ```
*   **Tests:** Integration test that verifies no console errors are thrown when interacting with components that use mixed listener types.
*   **CI Check:** A linter could flag `preventDefault()` calls inside functions attached as passive listeners, though this may be difficult to track statically.

#### RULE: Event Bus Contracts (MUST)
*   **Statement:** Any `subscribe()` method on an event bus **MUST** return an `unsubscribe()` function. Components **MUST** call this function in their `destroy()` method.
*   **Rationale:** Failure to unsubscribe from a global or shared event bus is a common source of memory leaks and logic errors, where "dead" components continue to react to events.
*   **Good:**
    ```javascript
    class MyComponent {
      #unsubscribe;
      constructor() {
        this.#unsubscribe = eventBus.subscribe('user:logout', () => this.cleanup());
      }
      destroy() {
        if (this.#unsubscribe) {
          this.#unsubscribe();
        }
      }
    }
    ```
*   **Tests:** Contract test for the event bus to ensure `subscribe` returns a function. Component tests must verify `unsubscribe` is called on destruction.
*   **CI Check:** Enforce that components with `eventBus.subscribe` also have a `destroy` method that calls the returned function.

#### RULE: Global API Exposure (SHOULD NOT)
*   **Statement:** Do not pollute the `window` object. If a global handle is absolutely necessary (e.g., for cleanup), use `Symbol.for('my-app.feature')` as the key.
*   **Rationale:** Attaching properties to `window` creates a high risk of collision with third-party scripts or other parts of the application, leading to unpredictable bugs. Symbols provide a non-colliding namespace.
*   **Good:**
    ```javascript
    const CLEANUP_KEY = Symbol.for('my-app.citationCleanup');
    Object.defineProperty(window, CLEANUP_KEY, {
      value: cleanupFunction,
      configurable: true, // Allow deletion
    });
    ```
*   **Bad:**
    ```javascript
    // HIGH COLLISION RISK
    window.__citationCleanup = cleanupFunction;
    ```
*   **Tests:** Ensure that global handles are correctly set and removed, and do not persist across test suites.
*   **CI Check:** ESLint rule (`no-restricted-globals`) to ban direct assignment to `window`.

#### RULE: Client-Side Rate Limiting (SHOULD)
*   **Statement:** Event handlers that trigger frequent or resource-intensive operations (especially network requests) **SHOULD** be rate-limited using `debounce` or `throttle`.
*   **Rationale:** High-frequency events like `keyup`, `resize`, or `scroll` can trigger hundreds of handler executions per second. If these handlers perform expensive work like making API calls, it can degrade the user experience and place unnecessary load on backend services, potentially leading to a client-side Denial of Service (DoS). Throttling or debouncing ensures the handler logic is executed in a more controlled and performant manner. (Из Главы 7, "Throttling, debouncing, and batching asynchronous operations").
*   **Good (Debounce for "search-as-you-type"):**
    ```javascript
    // Debounce waits for a pause in user input before firing.
    const debouncedSearch = debounce(async (query) => {
      const results = await fetch(`/api/search?q=${query}`);
      // update UI...
    }, 300); // 300ms delay

    searchInput.addEventListener('keyup', (e) => {
      debouncedSearch(e.target.value);
    });
    ```
*   **Good (Throttle for scroll tracking):**
    ```javascript
    // Throttle ensures the function runs at most once per interval.
    const throttledScrollHandler = throttle(() => {
      // track scroll position...
    }, 100); // Max once every 100ms

    window.addEventListener('scroll', throttledScrollHandler, { passive: true });
    ```
*   **CI Check:** While hard to enforce statically, a linter rule can flag event listeners for `keyup`, `scroll`, and `resize` that directly contain a `fetch()` call and recommend wrapping it in a rate-limiting function.```

#### RULE: Idempotent Initialization (MUST)
*   **Statement:** Initialization logic, especially for global listeners, **MUST** be idempotent to prevent duplicate handlers and memory leaks.
*   **Rationale:** In modern frontend environments (HMR, SPAs, island hydration), a script can be executed multiple times. Non-idempotent initialization will attach duplicate listeners, leading to performance degradation and bugs.
*   **Good:**
    ```javascript
    const INIT_FLAG = Symbol.for('my-app.isInitialized');
    if (!document[INIT_FLAG]) {
      document.addEventListener('astro:page-load', safeInitialize);
      Object.defineProperty(document, INIT_FLAG, { value: true, configurable: true });
    }
    ```
*   **Tests:** Run the initialization function multiple times in a test and assert that event listeners are only attached once.
*   **CI Check:** This is a pattern that is best enforced through code review, though linters can encourage the use of module-scope flags.

#### RULE: Storage Key Policy (MUST)
*   **Statement:** Only approved key patterns are allowed for `localStorage` and `sessionStorage`. All storage access **MUST** go through a helper that enforces these patterns.
*   **Rationale:** Unstructured storage keys lead to collisions, difficulty in debugging, and no clear ownership. A policy prevents these issues.
*   **Good:**
    ```javascript
    // Helper library
    const ALLOWED_PREFIXES = /^(ui-|settings-|cache-)/;
    function safeSetStorage(key, value) {
      if (!ALLOWED_PREFIXES.test(key)) {
        throw new Error(`Invalid storage key: ${key}`);
      }
      localStorage.setItem(key, JSON.stringify(value));
    }
    ```
*   **Tests:** Fuzz the `safeSetStorage` helper with invalid keys and assert that it throws an error and does not write to storage.
*   **CI Check:** Ban direct calls to `localStorage.setItem` and `sessionStorage.setItem`, forcing use of the helper.

### C. Data & Logic

#### RULE: Global RegExp Safety (MUST)
*   **Statement:** Do not use `RegExp.prototype.test()` with the `g` (global) or `y` (sticky) flags on a single, reusable RegExp instance.
*   **Rationale:** The `.test()` method is stateful when used with `g` or `y` flags. The `lastIndex` property is updated after each match, leading to inconsistent and unpredictable results (`true`, `false`, `true`, `false`...) on repeated calls with the same input.
*   **Good (No `g` flag):**
    ```javascript
    const URL_REGEX = /url\(/i; // No 'g' flag
    if (URL_REGEX.test(someString)) { /* ... */ }
    if (URL_REGEX.test(anotherString)) { /* ... */ }
    ```
*   **Good (Reset `lastIndex`):**
    ```javascript
    const URL_REGEX_G = /url\(/gi; // 'g' flag is required for other reasons
    URL_REGEX_G.lastIndex = 0; // Reset state before testing
    if (URL_REGEX_G.test(someString)) { /* ... */ }
    ```
*   **Bad:**
    ```javascript
    const URL_REGEX_G = /url\(/gi;
    // First call might be true, second might be false on the same input.
    if (URL_REGEX_G.test(someString)) { /* ... */ }
    if (URL_REGEX_G.test(someString)) { /* This might fail! */ }
    ```
*   **Tests:** Unit test that calls the validation function repeatedly in a loop with the same input and asserts that the output is always deterministic.
*   **CI Check:** Custom ESLint rule to detect the use of `.test()` on a RegExp literal or variable that has the `/g` or `/y` flag.

#### **RULE: Client-Side API Response Validation (MUST)**
*   **Statement:** All data received from external APIs, even trusted first-party APIs, **MUST** be validated against an expected schema before being used by the application.
*   **Rationale:** An API could be compromised, return malformed data, or change its contract unexpectedly. Blindly trusting API responses can lead to unhandled exceptions, state corruption, and security vulnerabilities if the data is later passed to a DOM sink or other sensitive function. This extends our Zero Trust philosophy to our own infrastructure. (Inspired by Chapter 5.4).
*   **Good (Using a schema validator like Zod or Yup):**
    ```javascript
    import { z } from 'zod';

    const userSchema = z.object({
      id: z.string().uuid(),
      name: z.string(),
      isAdmin: z.boolean().default(false),
    });

    async function fetchUser(userId) {
      const response = await fetch(`/api/users/${userId}`);
      const rawData = await response.json();
      // Throws an error if data doesn't match the schema
      const validatedUser = userSchema.parse(rawData);
      return validatedUser;
    }
    ```
*   **Bad:**
    ```javascript
    // VULNERABLE: Blindly trusts the API response structure.
    async function fetchUser(userId) {
      const response = await fetch(`/api/users/${userId}`);
      const user = await response.json(); // No validation
      // user.name could be undefined, user.isAdmin could be a malicious string.
      return user;
    }
    ```
*   **CI Check:** A linter rule can encourage wrapping `fetch` responses in validation functions.

#### RULE: Cryptographic Integrity (MUST)
*   **Statement:** All randomness **MUST** be generated via the Web Crypto API (`crypto.getRandomValues`). `Math.random()` is forbidden for any security-sensitive context.
*   **Rationale:** `Math.random()` is a pseudo-random number generator (PRNG) that is not cryptographically secure and can be predicted, making it unsuitable for generating nonces, keys, or unique IDs.
*   **Good:**
    ```javascript
    // From a centralized, tested security utility
    function getSecureRandomBytes(len) {
      const array = new Uint8Array(len);
      window.crypto.getRandomValues(array);
      return array;
    }
    ```
*   **Tests:** Statistical verification (e.g., Chi-Squared test) on the output of random number generators to ensure uniform distribution.
*   **CI Check:** ESLint rule (`no-restricted-properties`) to ban `Math.random`.

#### RULE: Consistent Object Shapes (SHOULD)
*   **Statement:** When creating multiple objects that share the same logical structure, you **SHOULD** initialize their properties in a consistent order, preferably using constructors or factory functions.
*   **Rationale:** Adherence to this rule directly supports our core principle of **"Performance is a Security Feature" (1.6)**. The V8 JavaScript engine heavily optimizes property access for objects with a stable structure (a consistent "Hidden Class" or "Map"). Initializing properties in a non-deterministic order creates objects with different internal structures. This forces the JIT compiler into a slower, polymorphic or megamorphic state, degrading performance, especially in performance-sensitive code paths that process large numbers of objects. While often a micro-optimization, consistent object shapes contribute to a more predictable and performant system.
*   **Good (Consistent order via constructor or literal):**
    ```javascript
    // GOOD: The property order is always the same.
    class User {
      constructor(name, age) {
        this.name = name;
        this.age = age;
      }
    }
    const user1 = new User('Alice', 30);
    const user2 = new User('Bob', 32);

    // Also good for simple objects:
    const makeVector = (x, y) => ({ x, y });
    ```
*   **Bad (Inconsistent order):**
    ```javascript
    // BAD: The shape of the returned object depends on runtime conditions.
    function createObjectFromData(data) {
      const obj = {};
      if (data.hasNameFirst) {
        obj.name = data.name;
        obj.value = data.value;
      } else {
        obj.value = data.value;
        obj.name = data.name;
      }
      return obj; // This function produces objects with two different shapes.
    }
    ```*   **Tests:** Direct verification via unit tests is impractical. This rule should be validated through performance benchmarks on critical application paths and enforced during code review.
*   **CI Check:** A static linter rule for this is often too noisy to be practical. Enforcement relies on developer training (per section 5.3) and vigilant code reviews (per section 5.1), especially for code within loops or high-frequency functions.

---

## Part IV: Verification & Enforcement

### 4.1. Testing Requirements
A feature is not "done" until it is accompanied by tests that prove its security and resilience.
*   **Unit Tests:** Modules touching security primitives must have >= 90% test coverage.
*   **Adversarial & Fuzz Tests:** Functions parsing untrusted input (DOM data, API responses, user input) **MUST** be fuzzed with invalid, malicious, and unexpected data (e.g., `null`, `undefined`, prototype pollution payloads, non-string types).
*   **Integration Tests:** Test the interaction between components, especially regarding lifecycle (init/destroy) and event handling, to catch memory leaks and state corruption.

### 4.2. CI/CD Security Gates
The deployment pipeline **MUST** include these steps. A failure in any step **MUST** block deployment.
*   **Policy-as-Code:** Key rules (allowed storage prefixes, selector patterns) should be stored in a machine-readable format (YAML/JSON) and used by CI jobs for validation.
*   **Static Analysis (SAST):** Run ESLint with security-focused plugins and our custom rules derived from this constitution.
*   **Dependency Scanning (SCA):** Run `npm audit --audit-level=high` and a third-party SCA tool. High/Critical vulnerabilities must be triaged within a defined SLA.
*   **Test Execution:** Run the full suite of unit, integration, and adversarial tests.

### 4.3. Example CI Job
```yaml
jobs:
  security-and-test:
    name: Security Scan & Tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Install Dependencies
        run: npm ci

      - name: Linting & Static Analysis
        run: npm run lint:security # Runs ESLint with security rules

      - name: Dependency Vulnerability Scan
        run: npm audit --audit-level=high

      - name: Comprehensive Test Suite
        run: npm test # Includes unit, integration, and adversarial tests

      - name: Policy-as-Code Validation
        run: ./scripts/validate-policy.sh # Checks against policy YAML files
```

---

## Part V: Governance & Process

### 5.1. Ownership & Code Review
Every rule in this constitution has an owner. Every Pull Request **MUST** be reviewed by at least one other developer and pass the "Code Review Checklist" (see Appendix). Security-critical changes require an additional review from a security team member.

### 5.2. Dependency Management
We practice **Trust is Not Transitive**. Every new dependency must be vetted for maintenance, popularity, security history, and sub-dependencies. The `package-lock.json` file **MUST** be committed to the repository.

### 5.3. Training & Onboarding
All new developers must complete a 30-minute training session covering the Top 10 rules of this constitution.

### 5.4. Audits & Reviews
The Security Team will conduct quarterly audits to verify CI coverage, unresolved lint failures, policy exceptions, and overall adherence to this constitution.

---

## Part VI: Incident Response & Observability

### 6.1. Incident Response Playbook
A short playbook must be readily available, outlining the process:
1.  **Detection:** How an incident is identified (monitoring, user report).
2.  **Containment:** How to immediately stop the bleeding (e.g., disable a feature flag, roll back).
3.  **Eradication:** How to remove the root cause.
4.  **Recovery:** How to restore service safely.
5.  **Post-Mortem:** A blameless retrospective must be completed within 5 business days, with action items assigned.

The playbook must include an up-to-date contact list for on-call security and development owners.

### 6.2. Observability & Metrics (KPIs)
We **MUST** track, dashboard, and review the following KPIs:
*   Number of security-linter failures per PR.
*   Time-to-remediate for high-severity SCA alerts.
*   Percentage of modules with adversarial tests.
*   Number of active policy exceptions, including reason and expiry date.

---

## Appendix A: Operator's Quick Checklist

This checklist **MUST** be reviewed by the developer before submitting a Pull Request.

-   [ ] **Security:** Does my code handle untrusted input? Have I used the approved helpers for DOM manipulation, storage, and selectors?
-   [ ] **Lifecycle:** If my component creates listeners or subscriptions, is there a `destroy()` method that cleans them all up using `AbortController` or an `unsubscribe` function?
-   [ ] **Performance:** Am I using performant APIs (`IntersectionObserver`, WAAPI)? Have I avoided blocking the main thread?
-   [ ] **Accessibility:** Have I considered `prefers-reduced-motion`? Are all interactive elements keyboard-navigable and screen-reader friendly?
-   [ ] **Testing:** Have I added tests for the happy path, error conditions, and adversarial inputs?
-   [ ] **Policy:** Does my change comply with all `MUST` rules in the Security Constitution?

---

## Appendix B: Developer Tooling & Helpers

To make compliance easy, we provide a suite of tools.
*   **`@yourorg/sec-utils`:** An internal npm package containing helpers like `safeQuerySelector`, `safeSetStorage`, `addEventListenerWithAbort`, and `validateKeyframe`.
*   **`eslint-plugin-yourorg`:** A custom ESLint plugin that codifies the rules in this constitution.
*   **Pre-commit Hooks:** A pre-commit hook is configured to run fast lint checks and unit smoke tests before code can be committed.

---

## Appendix C: Reference Sanitization Implementation (`DOMPurify`)

To effectively implement the **Trusted Types** and **Defense in Depth** mandates, a robust, well-configured sanitization library is required. Our recommended and reference implementation is **DOMPurify**.

### C.1. Rationale

`DOMPurify` is a security-focused HTML sanitizer that is highly effective against DOM-based XSS. It is the cornerstone of our client-side security, providing a critical defense layer that works in all browsers, including those that do not support Trusted Types (like Firefox).

### C.2. Creating the `app-policy` for Trusted Types

The `app-policy` required by our CSP **MUST** use `DOMPurify` to create `TrustedHTML` objects. This ensures that even in supporting browsers, all HTML is sanitized before being injected.

**Implementation Example:**

```javascript
import DOMPurify from 'dompurify';

// This policy should be defined once in a central security module.
let appPolicy;

if (window.trustedTypes && trustedTypes.createPolicy) {
  appPolicy = trustedTypes.createPolicy('app-policy', {
    createHTML: (stringToSanitize) => {
      // Sanitize the string with a strict configuration.
      const sanitized = DOMPurify.sanitize(stringToSanitize, {
        USE_PROFILES: { html: true }, // Allow basic HTML tags
        RETURN_TRUSTED_TYPE: true,   // Return a TrustedHTML object
      });
      return sanitized;
    },
    // Define createScriptURL and createScript as needed, or have them throw.
    createScriptURL: () => { throw new TypeError('Dynamic script URLs are not allowed'); },
    createScript: () => { throw new TypeError('Dynamic scripts are not allowed'); },
  });
}
```

### C.3. Secure Fallback for Non-Trusted-Types Browsers

In browsers like Firefox, where `window.trustedTypes` is undefined, you must still sanitize. The logic should fall back to using `DOMPurify` and assigning to a safe sink like `.textContent` or, if HTML is necessary, ensuring the sanitization is just as strict.

**Implementation Example:**

```javascript
function secureSetHTML(element, htmlContent) {
  if (appPolicy) {
    // Trusted Types path (Chrome, Edge)
    element.innerHTML = appPolicy.createHTML(htmlContent);
  } else {
    // Secure fallback path (Firefox, Safari)
    const sanitized = DOMPurify.sanitize(htmlContent, {
      USE_PROFILES: { html: true }
    });
    element.innerHTML = sanitized;
  }
}
```
